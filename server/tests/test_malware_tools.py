"""Tests for malware analysis tools (triage, IOC extraction, anti-analysis, YARA generation).

Tests verify that:
1. Triage provides accurate binary information
2. IOC extraction finds indicators correctly
3. Anti-analysis detection identifies evasion techniques
4. YARA rule generation produces valid rules
"""

import pytest
from conftest import TestToolTemplate

# Import tools
from ghidra_assist.tools.triage import TriageBinary
from ghidra_assist.tools.ioc_extract import ExtractIOCs
from ghidra_assist.tools.anti_analysis import DetectAntiAnalysis
from ghidra_assist.tools.yara_gen import GenerateYara


class TestTriageBinary(TestToolTemplate):
    """Test TriageBinary tool."""

    @pytest.mark.asyncio
    async def test_triage_binary(self, mock_cache):
        """Test automated binary triage."""
        mock_cache.bridge.triage_binary.return_value = {
            "architecture": "x86_64",
            "compiler": "Visual Studio",
            "executable_format": "PE",
            "entry_point": "0x401000",
            "packing": {"likely_packed": False},
            "sections": [
                {"name": ".text", "entropy": 5.2, "size": 4096},
                {"name": ".data", "entropy": 2.1, "size": 2048},
            ],
            "suspicious_imports": [],
            "suspicious_strings": [],
            "function_count": 342,
            "string_count": 891,
        }

        tool = TriageBinary()
        result = await tool.execute(
            repository="TestRepo",
            program="malware.exe"
        )

        self.assert_success(result)
        assert result["architecture"] == "x86_64"
        assert result["function_count"] == 342
        assert len(result["sections"]) == 2

    @pytest.mark.asyncio
    async def test_triage_detects_packing(self, mock_cache):
        """Test that triage detects packed binaries by entropy."""
        mock_cache.bridge.triage_binary.return_value = {
            "architecture": "x86_64",
            "packing": {
                "likely_packed": True,
                "reason": "High entropy in .text (7.8 > 7.0)",
                "packed_sections": [".text", ".rsrc"],
            },
            "sections": [
                {"name": ".text", "entropy": 7.8},  # High entropy = packed
            ],
            "suspicious_imports": ["VirtualAlloc", "WriteProcessMemory"],
        }

        tool = TriageBinary()
        result = await tool.execute(
            repository="TestRepo",
            program="packed_malware.exe"
        )

        self.assert_success(result)
        assert result["packing"]["likely_packed"] == True


class TestExtractIOCs(TestToolTemplate):
    """Test ExtractIOCs tool."""

    @pytest.mark.asyncio
    async def test_extract_ips(self, mock_cache):
        """Test extracting IP addresses from strings."""
        mock_cache.bridge.extract_iocs.return_value = {
            "iocs": {
                "ipv4": [
                    {"value": "192.168.1.100", "address": "0x2000", "type": "IPv4"},
                    {"value": "10.0.0.1", "address": "0x2010", "type": "IPv4"},
                ],
                "urls": [],
                "domains": [],
                "registry_keys": [],
                "file_paths": [],
            },
            "total_count": 2,
        }

        tool = ExtractIOCs()
        result = await tool.execute(
            repository="TestRepo",
            program="malware.exe"
        )

        self.assert_success(result)
        assert len(result["iocs"]["ipv4"]) == 2
        assert "192.168.1.100" in [ioc["value"] for ioc in result["iocs"]["ipv4"]]

    @pytest.mark.asyncio
    async def test_extract_domains_and_urls(self, mock_cache):
        """Test extracting domains and URLs."""
        mock_cache.bridge.extract_iocs.return_value = {
            "iocs": {
                "ipv4": [],
                "urls": [
                    {"value": "http://malicious.com/payload", "address": "0x2000"},
                    {"value": "https://c2.attacker.ru/beacon", "address": "0x2050"},
                ],
                "domains": [
                    {"value": "malicious.com", "address": "0x2000"},
                    {"value": "c2.attacker.ru", "address": "0x2050"},
                ],
                "registry_keys": [],
                "file_paths": [],
            },
            "total_count": 4,
        }

        tool = ExtractIOCs()
        result = await tool.execute(
            repository="TestRepo",
            program="trojan.exe"
        )

        self.assert_success(result)
        assert len(result["iocs"]["urls"]) == 2
        assert len(result["iocs"]["domains"]) == 2

    @pytest.mark.asyncio
    async def test_extract_registry_keys(self, mock_cache):
        """Test extracting Windows registry keys."""
        mock_cache.bridge.extract_iocs.return_value = {
            "iocs": {
                "ipv4": [],
                "urls": [],
                "domains": [],
                "registry_keys": [
                    {"value": "HKLM\\Software\\Microsoft\\Windows\\Run", "address": "0x2100"},
                    {"value": "HKCU\\Software\\Policies\\Microsoft\\Windows", "address": "0x2200"},
                ],
                "file_paths": [],
            },
            "total_count": 2,
        }

        tool = ExtractIOCs()
        result = await tool.execute(
            repository="TestRepo",
            program="persistence.exe"
        )

        self.assert_success(result)
        assert len(result["iocs"]["registry_keys"]) == 2


class TestDetectAntiAnalysis(TestToolTemplate):
    """Test DetectAntiAnalysis tool."""

    @pytest.mark.asyncio
    async def test_detect_anti_debug(self, mock_cache):
        """Test detecting anti-debugging techniques."""
        mock_cache.bridge.detect_anti_analysis.return_value = {
            "techniques": [
                {
                    "category": "anti_debug",
                    "technique": "IsDebuggerPresent",
                    "locations": [{"address": "0x401234", "function": "anti_debug_check"}],
                    "severity": "high",
                    "bypass_suggestion": "NOP the conditional jump at 0x401238",
                }
            ],
            "summary": {"anti_debug": 1, "anti_vm": 0, "anti_sandbox": 0},
        }

        tool = DetectAntiAnalysis()
        result = await tool.execute(
            repository="TestRepo",
            program="malware.exe"
        )

        self.assert_success(result)
        assert result["summary"]["anti_debug"] == 1
        assert result["techniques"][0]["technique"] == "IsDebuggerPresent"

    @pytest.mark.asyncio
    async def test_detect_anti_vm(self, mock_cache):
        """Test detecting anti-VM techniques."""
        mock_cache.bridge.detect_anti_analysis.return_value = {
            "techniques": [
                {
                    "category": "anti_vm",
                    "technique": "CPUID check for hypervisor",
                    "locations": [{"address": "0x401500", "function": "check_vm"}],
                    "severity": "medium",
                    "bypass_suggestion": "Patch CPUID instruction result",
                }
            ],
            "summary": {"anti_debug": 0, "anti_vm": 1, "anti_sandbox": 0},
        }

        tool = DetectAntiAnalysis()
        result = await tool.execute(
            repository="TestRepo",
            program="vm_aware_malware.exe"
        )

        self.assert_success(result)
        assert result["summary"]["anti_vm"] == 1

    @pytest.mark.asyncio
    async def test_multiple_anti_analysis_techniques(self, mock_cache):
        """Test detecting multiple evasion techniques in one sample."""
        mock_cache.bridge.detect_anti_analysis.return_value = {
            "techniques": [
                {
                    "category": "anti_debug",
                    "technique": "IsDebuggerPresent",
                    "severity": "high",
                },
                {
                    "category": "anti_vm",
                    "technique": "VMware detection",
                    "severity": "medium",
                },
                {
                    "category": "timing_check",
                    "technique": "GetTickCount timing check",
                    "severity": "low",
                },
            ],
            "summary": {"anti_debug": 1, "anti_vm": 1, "timing_checks": 1},
        }

        tool = DetectAntiAnalysis()
        result = await tool.execute(
            repository="TestRepo",
            program="sophisticated_malware.exe"
        )

        self.assert_success(result)
        assert len(result["techniques"]) == 3
        assert result["summary"]["anti_debug"] == 1
        assert result["summary"]["anti_vm"] == 1


class TestGenerateYara(TestToolTemplate):
    """Test GenerateYara tool."""

    @pytest.mark.asyncio
    async def test_generate_yara_rule(self, mock_cache):
        """Test generating a YARA rule from binary indicators."""
        mock_yara = """rule trojan_Generic {
    meta:
        description = "Generic trojan detected by YAGMCP"
        author = "YAGMCP"
    strings:
        $s1 = "http://malicious.com"
        $s2 = "VirtualAlloc"
        $h1 = {55 48 89 E5}
    condition:
        2 of ($s*) or $h1
}"""

        mock_cache.bridge.generate_yara.return_value = {
            "rule": mock_yara,
            "indicators_used": {"strings": 2, "hex_patterns": 1, "imports": 3},
            "confidence": "medium",
        }

        tool = GenerateYara()
        result = await tool.execute(
            repository="TestRepo",
            program="malware.exe",
            rule_name="trojan_Generic"
        )

        self.assert_success(result)
        assert "rule trojan_Generic" in result["rule"]
        assert "$s1" in result["rule"]  # String indicators
        assert result["indicators_used"]["strings"] == 2

    @pytest.mark.asyncio
    async def test_generate_yara_with_imports_focus(self, mock_cache):
        """Test YARA rule generation focused on suspicious imports."""
        mock_yara = """rule malware_imports {
    imports:
        "VirtualAllocEx"
        "WriteProcessMemory"
        "CreateRemoteThread"
    condition:
        all of them
}"""

        mock_cache.bridge.generate_yara.return_value = {
            "rule": mock_yara,
            "indicators_used": {"strings": 0, "imports": 3},
            "confidence": "high",
        }

        tool = GenerateYara()
        result = await tool.execute(
            repository="TestRepo",
            program="inject_malware.exe",
            focus="imports"
        )

        self.assert_success(result)
        assert "CreateRemoteThread" in result["rule"]
        assert result["indicators_used"]["imports"] == 3
