"""Tests for malware analysis tools (triage, IOC extraction, anti-analysis, YARA generation).

Tests verify that:
1. Triage provides accurate binary information
2. IOC extraction finds indicators correctly
3. Anti-analysis detection identifies evasion techniques
4. YARA rule generation produces valid rules
"""

import pytest
from tests import TestToolTemplate

# Import tools
from ghidra_assist.tools.triage import TriageBinary
from ghidra_assist.tools.ioc_extract import ExtractIOCs
from ghidra_assist.tools.anti_analysis import DetectAntiAnalysis
from ghidra_assist.tools.yara_gen import GenerateYara


class TestTriageBinary(TestToolTemplate):
    """Test TriageBinary tool."""

    @pytest.mark.asyncio
    async def test_triage_binary(self, mock_cache):
        """Test automated binary triage."""
        tool = TriageBinary()
        result = await tool.execute(
            repository="TestRepo",
            program="malware.exe"
        )

        self.assert_success(result)
        # Verify the structure and that it contains expected keys
        data = self.get_data(result)
        assert "architecture" in data
        assert "compiler" in data
        assert "executable_format" in data
        assert "function_count" in data
        assert "string_count" in data
        assert "sections" in data
        assert "packing" in data

    @pytest.mark.asyncio
    async def test_triage_detects_packing(self, mock_cache):
        """Test that triage detects packed binaries by entropy."""
        # Override default sections with high-entropy ones to trigger packing detection
        mock_cache.bridge.get_section_entropy.return_value = [
            {"name": ".text", "entropy": 7.8, "size": 4096, "initialized": True},  # High entropy = packed
            {"name": ".data", "entropy": 2.1, "size": 2048, "initialized": True},
        ]
        mock_cache.bridge.list_imports.return_value = [
            {"name": "VirtualAlloc", "address": "0x400000"},
            {"name": "WriteProcessMemory", "address": "0x400010"},
        ]

        tool = TriageBinary()
        result = await tool.execute(
            repository="TestRepo",
            program="packed_malware.exe"
        )

        self.assert_success(result)
        # Packing should be detected due to high entropy
        assert self.get_data(result)["packing"]["likely_packed"] == True


class TestExtractIOCs(TestToolTemplate):
    """Test ExtractIOCs tool."""

    @pytest.mark.asyncio
    async def test_extract_ips(self, mock_cache):
        """Test extracting IP addresses from strings."""
        # Mock list_strings to return strings containing IP addresses
        mock_cache.bridge.list_strings.return_value = [
            {"value": "Connecting to 192.168.1.100", "address": "0x2000", "length": 28},
            {"value": "Fallback IP: 10.0.0.1", "address": "0x2010", "length": 21},
            {"value": "localhost", "address": "0x2020", "length": 9},
        ]

        tool = ExtractIOCs()
        result = await tool.execute(
            repository="TestRepo",
            program="malware.exe"
        )

        self.assert_success(result)
        # Check that IPs were extracted
        assert len(self.get_data(result)["iocs"]["ipv4"]) >= 2
        ip_values = [ioc["value"] for ioc in self.get_data(result)["iocs"]["ipv4"]]
        assert "192.168.1.100" in ip_values
        assert "10.0.0.1" in ip_values

    @pytest.mark.asyncio
    async def test_extract_domains_and_urls(self, mock_cache):
        """Test extracting domains and URLs."""
        # Mock list_strings to return strings containing URLs and domains
        mock_cache.bridge.list_strings.return_value = [
            {"value": "http://malicious.com/payload", "address": "0x2000", "length": 30},
            {"value": "https://c2.attacker.ru/beacon", "address": "0x2050", "length": 31},
        ]

        tool = ExtractIOCs()
        result = await tool.execute(
            repository="TestRepo",
            program="trojan.exe"
        )

        self.assert_success(result)
        # Check that URLs and domains were extracted
        assert len(self.get_data(result)["iocs"]["urls"]) >= 2
        assert len(self.get_data(result)["iocs"]["domains"]) >= 2

    @pytest.mark.asyncio
    async def test_extract_registry_keys(self, mock_cache):
        """Test extracting Windows registry keys."""
        # Mock list_strings to return strings containing registry keys
        mock_cache.bridge.list_strings.return_value = [
            {"value": "HKLM\\Software\\Microsoft\\Windows\\Run", "address": "0x2100", "length": 40},
            {"value": "HKCU\\Software\\Policies\\Microsoft\\Windows", "address": "0x2200", "length": 44},
        ]

        tool = ExtractIOCs()
        result = await tool.execute(
            repository="TestRepo",
            program="persistence.exe"
        )

        self.assert_success(result)
        # Check that registry keys were extracted
        assert len(self.get_data(result)["iocs"]["registry_keys"]) >= 2


class TestDetectAntiAnalysis(TestToolTemplate):
    """Test DetectAntiAnalysis tool."""

    @pytest.mark.asyncio
    async def test_detect_anti_debug(self, mock_cache):
        """Test detecting anti-debugging techniques."""
        # Mock imports to include anti-debug APIs
        mock_cache.bridge.list_imports.return_value = [
            {"name": "IsDebuggerPresent", "address": "0x400100"},
            {"name": "kernel32.dll", "address": "0x400000"},
        ]
        mock_cache.bridge.list_strings.return_value = [
            {"value": "normal string", "address": "0x405000"},
        ]

        tool = DetectAntiAnalysis()
        result = await tool.execute(
            repository="TestRepo",
            program="malware.exe"
        )

        self.assert_success(result)
        # Should detect anti-debug due to IsDebuggerPresent import
        assert self.get_data(result)["summary"]["anti_debug"] >= 1

    @pytest.mark.asyncio
    async def test_detect_anti_vm(self, mock_cache):
        """Test detecting anti-VM techniques."""
        # Mock imports and strings to trigger anti-VM detection
        mock_cache.bridge.list_imports.return_value = [
            {"name": "NtQuerySystemInformation", "address": "0x400100"},
        ]
        mock_cache.bridge.list_strings.return_value = [
            {"value": "VMware", "address": "0x405000"},  # VM string
        ]

        tool = DetectAntiAnalysis()
        result = await tool.execute(
            repository="TestRepo",
            program="vm_aware_malware.exe"
        )

        self.assert_success(result)
        # Should detect anti-VM due to NtQuerySystemInformation import and VMware string
        assert self.get_data(result)["summary"]["anti_vm"] >= 1

    @pytest.mark.asyncio
    async def test_multiple_anti_analysis_techniques(self, mock_cache):
        """Test detecting multiple evasion techniques in one sample."""
        # Mock imports and strings with multiple anti-analysis indicators
        mock_cache.bridge.list_imports.return_value = [
            {"name": "IsDebuggerPresent", "address": "0x400100"},
            {"name": "NtQuerySystemInformation", "address": "0x400110"},
            {"name": "GetTickCount", "address": "0x400120"},
        ]
        mock_cache.bridge.list_strings.return_value = [
            {"value": "VMware detection code", "address": "0x405000"},
            {"value": "Normal string", "address": "0x405010"},
        ]

        tool = DetectAntiAnalysis()
        result = await tool.execute(
            repository="TestRepo",
            program="sophisticated_malware.exe"
        )

        self.assert_success(result)
        # Should detect multiple techniques
        techniques = self.get_data(result)["techniques"]
        assert len(techniques) >= 3
        assert self.get_data(result)["summary"]["anti_debug"] >= 1
        assert self.get_data(result)["summary"]["anti_vm"] >= 1


class TestGenerateYara(TestToolTemplate):
    """Test GenerateYara tool.

    Note: GenerateYara tests require Ollama LLM service running on localhost:11434.
    These tests are skipped by default.
    """

    @pytest.mark.asyncio
    @pytest.mark.skip(reason="Requires Ollama LLM service on localhost:11434")
    async def test_generate_yara_rule(self, mock_cache):
        """Test generating a YARA rule from binary indicators."""
        mock_yara = """rule trojan_Generic {
    meta:
        description = "Generic trojan detected by YAGMCP"
        author = "YAGMCP"
    strings:
        $s1 = "http://malicious.com"
        $s2 = "VirtualAlloc"
        $h1 = {55 48 89 E5}
    condition:
        2 of ($s*) or $h1
}"""

        mock_cache.bridge.generate_yara.return_value = {
            "rule": mock_yara,
            "indicators_used": {"strings": 2, "hex_patterns": 1, "imports": 3},
            "confidence": "medium",
        }

        tool = GenerateYara()
        result = await tool.execute(
            repository="TestRepo",
            program="malware.exe",
            rule_name="trojan_Generic"
        )

        self.assert_success(result)
        assert "rule trojan_Generic" in self.get_data(result)["rule"]
        assert "$s1" in self.get_data(result)["rule"]  # String indicators
        assert self.get_data(result)["indicators_used"]["strings"] == 2

    @pytest.mark.asyncio
    @pytest.mark.skip(reason="Requires Ollama LLM service on localhost:11434")
    async def test_generate_yara_with_imports_focus(self, mock_cache):
        """Test YARA rule generation focused on suspicious imports."""
        mock_yara = """rule malware_imports {
    imports:
        "VirtualAllocEx"
        "WriteProcessMemory"
        "CreateRemoteThread"
    condition:
        all of them
}"""

        mock_cache.bridge.generate_yara.return_value = {
            "rule": mock_yara,
            "indicators_used": {"strings": 0, "imports": 3},
            "confidence": "high",
        }

        tool = GenerateYara()
        result = await tool.execute(
            repository="TestRepo",
            program="inject_malware.exe",
            focus="imports"
        )

        self.assert_success(result)
        assert "CreateRemoteThread" in self.get_data(result)["rule"]
        assert self.get_data(result)["indicators_used"]["imports"] == 3
